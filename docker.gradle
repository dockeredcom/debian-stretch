/******************************************************************************
*                                                                              *
*   DOCKER GRADLE PLUGIN                                                              *
*                                                                              *
*   This gradle file contains the tasks needed to build and run a docker       *
*   image. In the future, this will become a specific gradle plugin,           *
*   but for now, code is separated into this file for a cleaner build.gradle.  *
*                                                                              *
*   for Mac and Linux only for now                                             *
*   on Windows, try Cygwin or something alike to have a real bash shell        *
*               but it has not been tested (yet)                               *
*                                                                              *
*   Version 1.0.0                                                              *
*   Yves Vindevogel                                                            *
*   2018-08-14                                                                 *
*                                                                              *
*   For full history of this file, see CHANGELOG.md                            *
*                                                                              *
 ******************************************************************************/

// For usage with "gradle tasks"
def gradleGroup = "Docker"

/*
*
* The clean task removes the image from the local docker images.
*
 */

task clean() {
  group = gradleGroup
  description = "Removes the image"

  doLast {
    def tag = "build"

    if (project.hasProperty("tag")) {
      tag = project.property("tag")
    }

    def count = countImages(tag)

    if (count > 0) {
      def cmd = "docker rmi -f ${project.ext.docker.repository}/" + \
                "${project.ext.docker.image}:${tag}"

      project.ext.runCommand cmd
    }
  }
}

/*
*
* The cleanSystem task removes as much as possible traces of docker on the
* complete system.
*
* WARNING: USE WITH CARE.
*
 */

task cleanSystem() {
  group = gradleGroup
  description = "Performs a system prune"

  doLast {
    def cmd = "yes | docker system prune"

    project.ext.runCommand cmd
  }
}

/*
*
* The build task builds the image.
*
* If no tag was given, it uses "build" as tag. This is related to the GitLab
* setup used. All pushes to the server must be done to specific branches.
* develop is a protected branch. The code in the specific branch will be merged
* into develop with a formal merge request in GitLab. So basically, when
* building from the develop, release or master branch, the tag will be given
* accordingly. But for local builds during development, "build" is the default.
*
* The parameters needed are given in the build.gradle file.
*
 */

task build {
  group = gradleGroup
  description = "Builds the image"

  doLast {
    def tag = "build"

    if (project.hasProperty("tag")) {
      tag = project.property("tag")
    }

    def cmd = "docker build -t ${project.ext.docker.repository}/" + \
              "${project.ext.docker.image}:${tag} " + \
              "-f ${rootDir}/src/docker/Dockerfile " + \
              "${rootDir}/src/docker"

    project.ext.runCommand cmd
  }
}

/*
*
* The run task starts a container based on the image.
*
* If no tag was given, it uses "build" as tag. (see task build)
* Parameters are set in the build.gradle file.
*
 */

task run {
  group = gradleGroup
  description = "Runs a container based on the image"

  doLast {
    def tag = "build"

    if (project.hasProperty("tag")) {
      tag = project.property("tag")
    }

    def cmd = "docker run --rm -t -d --name ${project.ext.docker.name} " + \
               "${project.ext.docker.repository}/" + \
               "${project.ext.docker.image}:${tag} " + \
               "/bin/bash"

    project.ext.runCommand cmd
  }
}

/*
*
* The stop task stops the running container based on the image.
*
* Parameters are set in the build.gradle file.
*
 */

task stop {
  group = gradleGroup
  description = "Stops the container"

  doLast {
    def cmd = "docker container stop ${project.ext.docker.name}"

    project.ext.runCommand cmd
  }
}

/*
*
* The initDirectories method can be used in the build.gradle file to
* automatically create the base directory structure used in this project.
*
 */

ext.initDirectories = {
  def baseDirectories = ["src/main/docker", "src/main/resources", "src/test", "build"]
  def baseFiles = ["src/main/docker/Dockerfile", ".gitignore"]

  baseDirectories.each { baseDirName ->
    def baseDir = new File("${rootDir}/${baseDirName}")

    if (!baseDir.exists()) {
      baseDir.mkdirs()
    }
  }

  baseFiles.each { baseFileName ->
    def baseFile = new File("${rootDir}/${baseFileName}")

    if (!baseFile.exists()) {
      baseFile << " "
    }
  }
}




/*
*
* Execute a bash shell command, with no regards of the output
*
 */

ext.runCommand = { String cmd ->
  def execCmd = ["/bin/bash", "-c"]
  execCmd += cmd

  project.exec {
    commandLine = execCmd
  }
}

/*
*
* Execute a bash shell command and capture the output into a return.
*
 */

ext.getCommandResult = { String cmd ->
  def out = new ByteArrayOutputStream()
  def execCmd = ["/bin/bash", "-c"]
  execCmd += cmd

  project.exec {
    commandLine = execCmd
    standardOutput = out
  }

  return out.toString()
}

/*
*
* Count the existing images in the local docker setup.
*
* This is a supporting function called in several tasks.
*
 */

def countImages(String tag) {
  def cmd = "docker images ${project.ext.docker.repository}/" + \
            "${project.ext.docker.image}:${tag} " + \
            "--format '{{.ID}}' | wc -l"

  return project.ext.getCommandResult(cmd).toInteger()
}

/*
*
* Checks if a container (not image!) exists on the local docker environment.
*
* This is a supporting function called in several tasks.
*
 */

def containerExists(String name) {
  def cmd = "docker container ls -a --format '{{.Names}}' | " + \
            "grep -w ${name} | wc -l"

  return project.ext.getCommandResult(cmd).toInteger() > 0
}












def optimize(File srcFile, File targetFile) {
    try {
        def previousCommand = ""
        def content = ""
        def nextLineContinued = false
        def nextCommandContinued = false
        def command = ""

        srcFile.eachLine {
            def line = it.trim()

            // Skip empty lines and comment lines
            if (line.length() > 0 && line.substring(0, 1) != "#") {
                if (nextLineContinued) {
                    def extraSpaces = nextCommandContinued ? 0 : 4

                    content += "\n${' ' * (command.length() + extraSpaces)} ${line.trim()}"
                } else {
                    command = line.split(" ")[0].toUpperCase()

                    // Adding the set -x by default
                    if (command == "RUN") {
                        if (previousCommand != "RUN") {
                            content += ("\nRUN set -x")
                        }

                        content += " && \\ \n    ${line.substring(4).trim()}"
                    } else {
                        if (previousCommand == "RUN") {
                            content += "\n"
                        }

                        if (previousCommand != command && previousCommand != "") {
                            content += "\n"
                        }

                        content += "${command.toUpperCase()} ${line.substring(command.length() + 1).trim()}\n"
                    }
                }

                previousCommand = command
                nextLineContinued = line.endsWith("\\")
                nextCommandContinued = line.replaceAll(' ', '').endsWith("&&\\")
            } else {
                // Yves Vindevogel
                // 2018-08-14
                // The below line makes absulutely no sense, but, if the line is not there, IntelliJ complains
                // that not all paths are returning a value.  Which is logical when you would look at the code.
                // You would have several lines of 'text', all without a single character.  So just a bunch of line
                // breaks only, or just comment lines.
                // I decided to write the line anyway, as I like the GroovyInspector to show me all is valid
                //
                // Not all execution paths return a value less... (⌘F1)
                // This inspection reports on missing Groovy return statement at the end of methods returning
                // Powered by InspectorGroovy

                content += ""
            }
        }

        if (targetFile.exists()) {
          targetFile.delete()
        }

        targetFile << content

    } catch (Exception e) {
        throw new Exception("Could not parse the code, " + \
                     "please check the code with docker build first to verify it does not throw an exception." + \
                     "\n\nException found: ${e.toString()}")
    }
}
